## 5 람다로 프로그래밍
Lambda Expression : 다른함수에 넘길수 있는 작은 코드 조각

### 5.1 람다식과 멤버참조
#### 5.1.1 람다소개 : 코드블록을 함수인자로 넘기기
"이벤트가 발생하면 이 핸들러를 실행하자" or "데이터구조의 모든 원소에 이연산을 적용하자"를 코드로 표현하는 방법  
예전 자바 : 무명내부클래스를 사용함   
함수형 프로그래밍 : 함수를 값처럼 다루는 접근방법을 택함. 함수를 직접 다른 함수에 전달할수 있다.  

//5.1 무명내부클래스로 리스너 구현하기 
  
```
//java  
fab.setOnClickListener ( new View.OnClickListener () {  
    @Override  
    public void onClick(View view) {  
        ...
    }  
});  
```
//5.2 람다로 리스너 구현하기  
```
    fab.setOnClickListener {  
        view ->  
        ...  
    }   
```    

#### 5.1.2 람다와 컬렉션
람다가 없다면 컬렉션을 편리하게 처리할 수 있는 좋은 라이브러리를 제공하기 힘들다.
자바개발자는 필요한 컬렉션 기능을 직접 작성하고 했지만. 코틀린에서 그런 습관은 버려야 한다.

//리스트 5.3 컬렉션을 직접 검색하기
```
println(people.maxBy { it.age })
data class Person(val name: String, val age : Int)  
fun findTheOldest(people: List<Person>){    
    var maxAge = 0  
    var theOldest : Person? = null  
    for(person in people){  
        if ( person.age > maxAge){  
            maxAge = person.age  
            theOldest = person  
        }  
    }  
    println(theOldest)  
}  

fun main(args : Array<String>){  
    val people = listOf(Person("Alice", 29), Person("Bob", 31))  
    findTheOldest(people)  
}  
```

// 리스트 5.4 람다를 사용해 컬렉션 검색하기   
    ```
println(people.maxBy { it.age }) 
    ```
    
maxBy는 가장 큰 원소를 찾기 위해 비교에 사용할 값을 돌려주는 함수를 인자로 받는다.  
컬렌션의 원소를 인자로 받아서(it이 그 인자를 가리킨다) 비교에 사용할 값을 반환한다.  
람다는 멤버 참조로 대치할수 있다.
  
// 리스트 5.5 멤버참조를 사용해 컬렉션 검색하기  
```
 println(people.maxBy (  Person::age  ) )  
 ```
 
    
#### 5.1.3 람다식의 문법
```
       파라미터       본문   
{ x : Int, y: Int -> x + y }  
```
항상 중괄호 사이에 위치함  
그림 5.1 람다식 문법  

인자 목록 주변에 괄호가 없다는 사실을 꼭 기억하자. 화살표(->)가 인자 목록과 람다 본문을 구분해준다.  
람다식을 변수에 저장할수 있다.  
```
val sum = { x : Int, y: Int -> x+y }  
println(sum(1,2))  
3  
```

코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run을 사용한다. run은 인자로 받은 람다를 실행해주는 라이브라리 함수다.  
```
run {println(42)}   //람다본문에 있는 코드를 실행한다. 
42  
```

리스트 5.4에서 정식으로 람다를 작성하면 다음과 같다.  
```
people.maxBy({ p:Persom -> p.age})
```
중괄호에 있는 코드는 람다식이고 그 람다식을 maxBy함수에 넘긴다.   
코틀린에서는 함수 호출시 맨뒤에 있는 인자가 람다식이라면 그 람다를 괄호밖으로 빼낼수 있다.  
예제에서 람다가 유일한 인자이자 마지막 인자이므로 괄호뒤에 람다를 둘수 있다.
 ```
  people.maxBy(){ p:Persom -> p.age}
```
괄호뒤에 람다를 썼다면 호출시 빈 괄호를 없애도 된다.  
```  people.maxBy{ p:Persom -> p.age}```  
람다가 함수의 유일한 인자라면 괄호없이 람다를 바로 쓰기를 원하게 될것이다.  

joinToString예제를 다시 살펴보자.  
표준라이브러리의 joinToString은 맨 마지막인자로 하수를 더 받는다는 차이가 있다.  
리스트의 원소를 toString이 아닌 다른방식을 통해 문자열로 변환하고 싶은 경우 이 인자를 활용한다.  


    //리스트 5.6 이름붙인 인자를 사용해 람다 넘기기  
     val people = listOf(Person("Alice", 29), Person("Bob", 31))
     val names = people.joinToString (   separator = " ", transform = { p:Person -> p.name})
     
     println(names)
     > Alice Bob
     //5.7 람다를 괄호밖에 전달하기
     people.joinToString(" ") { p: Person -> p.name} 
     
     
리스트 5.7은 간결하지만 람다의, 용도를 분명히 알아볼수는 없다.

    //5.8 람다파라미터 타입 제거하기
    people.maxBy { p:Person -> p.age }  //파라미터 타입을 명시
    people.maxBy { p -> p.age } //파라미터타입을 생략(컴파일러가 추론)
    
 컴파일러는 람다 파라미터의 타입도 추론할수 있다. 따라서 파라미터 타입을 명시할 필요가 없다.  
 마지막으로 람다의 파라미터 이름을 디폴트 이름인 it으로 바꾸면 람다식을 더 간단하게 만들수 있다.  
 
     //5.9 디폴트 파라미터 이름 it 사용하기
     people.maxBy { it.age }
     
it은 코드를 아주 간단하게 만들어준다. 하지만 람다안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 편이 낫다.  
람다를 변수에 저장할때는 파라미터 타입을 명시해야 한다.


    val getAge = {p: Person -> p.age}
    people.maxBy(getAge)
    
본문이 여러줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과값이 된다.  

    val sum = {x: Int, y: Int ->
        println("Computing the sum of $x and $y...")
        x+y  //본문의 맨마지막에 있는 식이 람다의 결과값
    }
    println(sum(1,2))
    Computing the sum of 1 and 2...
    3              


#### 5.1.4 현재 영역에 있는 변수의 접근  
람다를 함수안에서 정의하면 함수의 파라미터뿐만 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할수 있다.  
forEach표준함수로 함수파라미터를 람다안에서 사용해 보자.  


    //5.10  함수파라미터를 람다안에서 사용하기
    fun printMessageWithPrefix(messages : Collection<String>, prefix :String ){
        messages.forEach { //각 원소에 대해 수행할 작업을 람다로 받는다.
            println("$prefix $it") //람다안에서 함수의 prefix파라미터를 사용한다.
        }
    }
    val errors = listOf("403 Forbidden", "404 Not Found")
    printMessageWithPrefix(errors, "Error:")
    
    Error: 403 Forbidden
    Error: 404 Not Found
    
자바와 다른점은 코틀린 람다안에서는 파이널 변수가 아닌 변수에 접근할수 있다는 점이다.
또한 람다안에서 바깥의 변수를 변경해도 된다. 

    // 5.11 람다안에서 바깥함수의 로컬변수 변경하기
    fun printProblemCounts(response : Collection<String>){
        var clientErrors = 0  //람다에서 사용할 변수를 정의한다.
        var serverErrors = 0
        response.forEach{
            if( it.startsWith("4"))
                clientErrors++  //람다에안에서 람다 밖의 변수를 변경한다.
            else if(it.startsWith("5"))
                serverErrors++
        }
        println("$clientErrors client errors, $serverErrors server errors")
    }  
    println("5.11 람다안에서 바깥함수의 로컬변수 변경하기")
    val responses = listOf("200 OK", "418 I'm a teapot", "500 Internal Server Error")
    printProblemCounts(responses)
    1 client errors, 1 server errors
    
코틀린에서는 자바와 달리 람다밖의, 함수에 있는 파이널이 아닌 변수에 접근을 할수 있고, 그 변수를 변경할수 있다.
예제의 prefix, clientErrors, serverErrors와 같이 람다안에서 사용하는 외부변수를 '람다가 포획한 변수' 라고 부른다.
기본적으로 함수안에 정의된 로컬 변수의 생명주기는 함수가 반환하면 끝난다.    
어떤 함수가 자신의 로컬변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질수 있다.  
포획한 변수가 있는 람다를 저장해서 함수가 끝난뒤에 실행해도 람다의 본문코드는 여전히 포획한 변수를 읽거나 쓸수 있다.

람다를 이벤트 핸들러나 비동기적으로 실행되는 코드로 활용시 함수 호출이 끝난다음에 로컬 변수가 변경될수도 있다.
    
    fun tryToCountButtonClicks(button: Button): Int{
        var clicks = 0
        button.onClick(clicks++)
        return clicks
    }  
이 함수는 0을 반환한다.
핸들러는 tryToCountButtonClicks가 clicks를 반환한다음에 호출되기 때문이다.
제대로 구현하려면 클릭횟수를 세는 카운터 변수를 함수의 내부가 아니라 클래스의 프로퍼티나 전역 프로퍼티위치로 빼서 함수 변화를 살펴보아야 한다.
  
#### 5.1.5 멤버 참조
코틀린에서는 함수를 값으로 바꿀수 있다. 이때 이중콜론(::)을 사용한다.  
val age = Person::age  
::를 사용하시는 식을 멤버참조(member reference)라고 부른다.  
```
클래스    멤버  
Person::age 
      :: 로 구분
그림 5.2 멤버참조구분             
```   
 멤버참조는 그 멤버를 호출하는 람다와 같은 타입이다.   
 다음 예처럼 자유롭게 바꿔쓸수 있다.
``` 
people.maxBy(Person::age)
people.maxBy(p -> p.age)
people.maxBy(it.age)
``` 
최상위에 선언된 함수느 프로퍼티를 참조할 수도 있다.

    fun salute() = println("Salute!")
    run ( ::salute )   //최상위함수를 참조한다.
    Salute!
    
클래스 이름을 생략하고 ::로 참조를 바로 시작한다.
::salute라는 멤버참조를 run라이브러리 함수에 넘긴다.(run은 인자로 받은 람다를 호출한다.)

    val action = {person:Person, message : String ->  //이 람다는 sendEmail함수에게 작업을 위임한다.
        sendEmail(person, message)
    }
    val nextAction = ::sendEmail  //람다대신 멤버참조를 쓸수 있다.

생성자 참조를 사용하면 클래스 생성작업을 연기하거나 저장해 둘수 있다.  
::뒤에 클래스 이름을 넣으면 생성자 참조를 만들수 있다.

        val createPerson = ::Person
        val p = createPerson("Alice", 29)
        println(p)
        Person(name=Alice, age=29)

확장함수도 멤버함수와 똑같은 방시으로 참조할수 있다.
    
    fun Person.isAdult() = age >=21
    val predicate = Person::isAdult
    
isAdult는 Person의 확장함수  
person.isAdult() 처럼 Person::isAdult 로 사용가능함                     

### 5.2 컬렉션 함수형 API
컬렉션을 다루는 코틀린 표준 라이브러리를 몇가지 살펴보자.
#### 5.2.1 필수적인 함수 : filter와 map
filter와 map은 컬렉션을 활용할 때 기반이 되는 함수이다.
filter함수는 Collection을 Iteration하면서 주어진 Lambda에 각 원소를 넘겨서 lambda가 true를 반환하는 원소만 모은다.  

        val list = listOf(1,2,3,4) 
        println( list.filter { it % 2 == 0 })
        [2, 4]
결과는 입력 컬렉션의 원소중에서 주어진 Predicate를 만족하는 원소만으로 이루어진 새로운 컬렉션이다.
filter함수는 컬렉션에서 원치않는 원소를 제거한다.

map함수는 주어진 lambda를 Collection의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다.

        val list = listOf(1,2,3,4) 
        println(list.map { it * it })
        [1, 4, 9, 16]
이름의 리스트를 출력하고싶다면 map으로 사람의 리스트를 이름의 리스트로 바꾸면 된다.

        val people = listOf(Person("Alice", 29), Person("Bob", 31))
        println(people.map {it.name})
        [Alice, Bob]
        
멤버참조를 사용할수도 있다.

    println(people.map(Person::name))
    
30살 이상인 사람의 이름을 출력해보자.

    println(people.filter{ it.age>=30}.map(Person::name))
    [Bob]
    
이제 이 목록에서 가장 나이 많은 사람의 이름을 알고싶다고 하자.
나이의 최대값을 구하고 나이가 그 최댓값과 같은 모든 사람을 반환하면 된다.

    //tip double bang
    //http://kotlinprogrammer.blogspot.com/2017/07/kotlin-double-exclamation-operator.html
    println(  people.maxBy(Person::age)!!.age )
    println( people.filter { it.age == people.maxBy(Person::age)!!.age } )
    42
    [Person(name=Ryan, age=42)]
최댓값을 구하는 작업을 반복한다는 단점이 있다. 100명의 사람이 있다면 100번 최대값을 연산한다.  

    val maxAge = people.maxBy(Person::age)!!.age
    people.filter { it.age == maxAge }
람다를 인자로 받는 함수에 람다를 넘기면 겉으로 볼때는 단순해 보이는 식이 내부 로직의 복잡도로 인해 실제로는 엄청나게 불합리한 계산식이 될 때가 있다.  

필터와 변환함수를 맵에 적용할 수도 있다.

    val numbers = mapOf( 0 to "zero" , 1 to "one")
    println( numbers.mapValues { it.value.toUpperCase() })  
    
filterKeys -> 키를 걸러냄
mapKeys -> 키를 변환함
filterValues -> 값을 걸러냄
mapValues -> 값을 변환함    
                  
        
        
         
                                            